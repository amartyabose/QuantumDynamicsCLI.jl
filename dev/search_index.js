var documenterSearchIndex = {"docs":
[{"location":"documentation/Spin-Boson/#Spin-Boson-Example","page":"Spin-Boson Simulations","title":"Spin-Boson Example","text":"","category":"section"},{"location":"documentation/Spin-Boson/","page":"Spin-Boson Simulations","title":"Spin-Boson Simulations","text":"Let us say we are trying to simulate a typical Spin-Boson problem, where all parameters are specified in atomic units.","category":"page"},{"location":"documentation/Spin-Boson/","page":"Spin-Boson Simulations","title":"Spin-Boson Simulations","text":"[system]\nHamiltonian = \"Hamiltonian\"\n\n[baths]\nbeta = 5.0\n[[baths.bath]]\ntype = \"ohmic\"\nxi = 0.1\nomegac = 7.5\nsvec = [1.0, -1.0]","category":"page"},{"location":"documentation/Spin-Boson/","page":"Spin-Boson Simulations","title":"Spin-Boson Simulations","text":"Notice that the [units] section is completely skipped over because the default values specify atomic units.","category":"page"},{"location":"documentation/ParseInput/#Inputs-to-qdsim","page":"qdsim Inputs","title":"Inputs to qdsim","text":"","category":"section"},{"location":"documentation/ParseInput/","page":"qdsim Inputs","title":"qdsim Inputs","text":"A simulation depends upon the specification of the system. This is done in the system TOML file, which specifies three different things:","category":"page"},{"location":"documentation/ParseInput/","page":"qdsim Inputs","title":"qdsim Inputs","text":"the units in use\nthe Hamiltonian for the problem being simulated:\nthe description of the system\nthe description of the bath or environment","category":"page"},{"location":"documentation/ParseInput/","page":"qdsim Inputs","title":"qdsim Inputs","text":"Along with this system TOML file, a simulation TOML file also needs to be prepared that provides the details of the simulation.","category":"page"},{"location":"documentation/ParseInput/#System-File","page":"qdsim Inputs","title":"System File","text":"","category":"section"},{"location":"documentation/ParseInput/","page":"qdsim Inputs","title":"qdsim Inputs","text":"Each of the three sections in the system file has a dedicated function for parsing the data. Before giving a full example of a system input file, we discuss the parameters accepted by the various sections.","category":"page"},{"location":"documentation/ParseInput/#Specifying-the-Units","page":"qdsim Inputs","title":"Specifying the Units","text":"","category":"section"},{"location":"documentation/ParseInput/","page":"qdsim Inputs","title":"qdsim Inputs","text":"QuantumDynamicsCLI.ParseInput.parse_unit","category":"page"},{"location":"documentation/ParseInput/#QuantumDynamicsCLI.ParseInput.parse_unit","page":"qdsim Inputs","title":"QuantumDynamicsCLI.ParseInput.parse_unit","text":"parse_unit(input_dict)\n\nParses the [units] section of the system TOML file. It takes two variables:\n\nParameters obtained:\n\nenergy_unit_name [Default: ha]: Specifies the energy units. Typically eV, meV, cm^-1, or ha.\ntime_unit_name [Default: au]: Specifies the time units. Typically fs, or au.\n\n\n\n\n\n","category":"function"},{"location":"documentation/ParseInput/#Specifying-the-Hamiltonian","page":"qdsim Inputs","title":"Specifying the Hamiltonian","text":"","category":"section"},{"location":"documentation/ParseInput/","page":"qdsim Inputs","title":"qdsim Inputs","text":"The basic problem under study has a general form, hatH = hatH_0 + hatH_textenv, where hatH_0 forms the system Hamiltonian and the hatH_textenv is the environment or bath Hamiltonian.","category":"page"},{"location":"documentation/ParseInput/#System-Hamiltonian","page":"qdsim Inputs","title":"System Hamiltonian","text":"","category":"section"},{"location":"documentation/ParseInput/","page":"qdsim Inputs","title":"qdsim Inputs","text":"QuantumDynamicsCLI.ParseInput.parse_system","category":"page"},{"location":"documentation/ParseInput/#QuantumDynamicsCLI.ParseInput.parse_system","page":"qdsim Inputs","title":"QuantumDynamicsCLI.ParseInput.parse_system","text":"parse_system(sys_inp, unit)\n\nParses the [system] portion of the system file for the Hamiltonian and converts it to atomic units for internal use.\n\nParameters obtained:\n\nHtype [Default: file]: How to parse the Hamiltonian file. Typically file to read a file, nearest_neighbor to specify the Hamiltonian as a nearest-neighbor tight-binding model, or nearest_neighbor_cavity for a Hamiltonian consisting of a nearest-neighbor tight-binding part and a cavity with interacts with all the sites.\n\nThen the Hamiltonian needs to be specified in the energy units that are being used. This can be done in several ways depending on the value of Htype:\n\nif Htype = file, put in the variable, Hamiltonian with the name of a file containing the elements of the Hamiltonian matrix.\nif Htype = \"nearest_neighbor\", specify the following variables:\nsite_energy: the energy of each site\ncoupling: the intersite coupling element\nnum_sites: the number of sites\nif Htype = \"nearest_neighbor_cavity\", in addition to the same variables as the Htype = \"nearest_neighbor\" case, also specify:\ncavity_energy: the energy of the cavity mode\ncavity_coupling: coupling of the cavity to the monomers\n\nFinally a parameter is_QuAPI [Default: true] specifies if the specified system Hamiltonian should be interpreted to be a part of the QuAPI system-bath Hamiltonian form or not.\n\n\n\n\n\n","category":"function"},{"location":"documentation/ParseInput/#Bath-Hamiltonian","page":"qdsim Inputs","title":"Bath Hamiltonian","text":"","category":"section"},{"location":"documentation/ParseInput/","page":"qdsim Inputs","title":"qdsim Inputs","text":"QuantumDynamicsCLI.ParseInput.parse_bath","category":"page"},{"location":"documentation/ParseInput/#QuantumDynamicsCLI.ParseInput.parse_bath","page":"qdsim Inputs","title":"QuantumDynamicsCLI.ParseInput.parse_bath","text":"parse_bath(baths, sys, unit)\n\nThis function parses the bath(s) interacting with the system. Currently only harmonic baths are supported.\n\nParameters:\n\nThe temperature for the simulation needs to be specfied. This can be done in one of two ways:\nbeta in units of 1/ha for the inverse temperature beta = frac1k_BT.\nor temperature in the units of Kelvin.\nA list of baths that interact with the system specified under [[baths.bath]] heading in the TOML file. Each bath is parsed by QuantumDynamicsCLI.ParseInput.get_bath.\n\n\n\n\n\n","category":"function"},{"location":"documentation/ParseInput/","page":"qdsim Inputs","title":"qdsim Inputs","text":"QuantumDynamicsCLI.ParseInput.get_bath","category":"page"},{"location":"documentation/ParseInput/#QuantumDynamicsCLI.ParseInput.get_bath","page":"qdsim Inputs","title":"QuantumDynamicsCLI.ParseInput.get_bath","text":"get_bath(b, unit)\n\nParse individual baths\n\nParameters:\n\ntype [Default: ohmic]: Type of harmonic bath. Can be ohmic, drude_lorentz, tabular, tabular_jw_over_w, huang_rhys\n\nThe parameters for the bath are specified in different ways for each different bath:\n\nif type=\"ohmic\", the bath spectral density J(omega)=frac2piDelta s^2hbarxiomega_cexpleft(-fracomegaomega_cright)\nxi: dimensionless Kondo parameter (xi)\nomegac: cutoff frequency (omega_c) in energy units\nDs [Default: 2]: Delta s value. Typically set to 1 for exciton transfer problems.\nnpoints [Default: 100000]: Number of points used in integration for the influence functional coefficients.\nomega_max [Default: 30.0 * omegac]: Upper limit of influence functional coefficient integrations\nif type=\"drude_lorentz\", the bath spectral density J(omega) = frac2lambdaDelta s^2fracomega gammaomega^2+gamma^2\nlambda: reorganization energy, lambda, in energy units\ngamma: cutoff frequency, gamma, in energy units\nDs [Default: 2]: Delta s value. Typically set to 1 for exciton transfer problems.\nnpoints [Default: 100000]: Number of points used in integration for the influence functional coefficients.\nomega_max [Default: 1000.0 * gamma]: Upper limit of influence functional coefficient integrations\nif type=\"tabular\", the bath spectral density is provided as a table in the file specified in jw_file\nif type=\"huang_rhys\", the bath spectral density is provided in the form of a table of frequency-dependent Huang-Rhys factors in the file specified in huang_rhys_file\n\n\n\n\n\n","category":"function"},{"location":"documentation/ParseInput/#Simulation-File","page":"qdsim Inputs","title":"Simulation File","text":"","category":"section"},{"location":"documentation/ParseInput/","page":"qdsim Inputs","title":"qdsim Inputs","text":"The simulation file has only a single TOML section [simulation]. Every simulation file should have a name to identify the simulation and an output file that specifies an HDF5 file for storing all the data.","category":"page"},{"location":"documentation/ParseInput/","page":"qdsim Inputs","title":"qdsim Inputs","text":"There are broadly three types of simulations that are currently supported:","category":"page"},{"location":"documentation/ParseInput/","page":"qdsim Inputs","title":"qdsim Inputs","text":"dynamics simulations that simulate the non-equilibrium dynamics of the given problem\nequilibrium_rho simulations that simulate the equilibrium density at the given temperature\ncomplex_corr simulations for calculating equilibrium correlation functions of various flavors","category":"page"},{"location":"documentation/ParseInput/","page":"qdsim Inputs","title":"qdsim Inputs","text":"These are specified in the calculation field which, if unspecified, is taken to be dynamics by default.","category":"page"},{"location":"documentation/ParseInput/","page":"qdsim Inputs","title":"qdsim Inputs","text":"The rest of the parameters required for a simulation file are specific to the type of simulation being run.","category":"page"},{"location":"documentation/ParseInput/#Dynamics-Simulations","page":"qdsim Inputs","title":"Dynamics Simulations","text":"","category":"section"},{"location":"documentation/ParseInput/","page":"qdsim Inputs","title":"qdsim Inputs","text":"Various methods of simulation are supported:","category":"page"},{"location":"documentation/ParseInput/","page":"qdsim Inputs","title":"qdsim Inputs","text":"Path Integral Methods using Feynman-Vernon Influence Functional[1]:\nQuasi-adiabatic Propagator Path Integrals (QuAPI) [2, 3]\nBlip QuAPI [4]\nTime-Evolved Matrix Product Operators (TEMPO) [5]\nPairwise-Connected Tensor Network Path Integral (PC-TNPI) [6]\nHierarchical Equations of Motion (HEOM) [7]\nGeneralized Quantum Master Equation\nMultichromophore Incoherest Forster Theory\nBloch-Redfield Master Equation\nTransfer Tensor Method (TTM) [12] coupled with any of the path integral methods","category":"page"},{"location":"documentation/ParseInput/","page":"qdsim Inputs","title":"qdsim Inputs","text":"All of these dynamics methods require some core common parameters and then more specfic method-dependent parameters. The core parameters of all the dynamics methods are:","category":"page"},{"location":"documentation/ParseInput/","page":"qdsim Inputs","title":"qdsim Inputs","text":"dt: for the time-step in the units specified in the system file\nnsteps: for the number of steps of simulation of the dynamics","category":"page"},{"location":"documentation/ParseInput/#Feynman-Vernon-Influence-Functional-Simulations","page":"qdsim Inputs","title":"Feynman-Vernon Influence Functional Simulations","text":"","category":"section"},{"location":"documentation/ParseInput/","page":"qdsim Inputs","title":"qdsim Inputs","text":"There are two ways of incorporating the effect of non-Markovian memory in path integral simulations: iterative propagation beyond memory or using the transfer tensor method. To use TTM, one can choose one of the following:","category":"page"},{"location":"documentation/ParseInput/","page":"qdsim Inputs","title":"qdsim Inputs","text":"method = \"QuAPI-TTM\": for using QuAPI within memory\nmethod = \"Blip-TTM\": for using Blip within memory\nmethod = \"TEMPO-TTM\": for using TEMPO within memory","category":"page"},{"location":"documentation/ParseInput/","page":"qdsim Inputs","title":"qdsim Inputs","text":"Finally, if one does not intend on using TTM, we suggest using TEMPO for accessing long memory lengths efficiently. This is chosen by setting method = \"TEMPO\".","category":"page"},{"location":"documentation/ParseInput/","page":"qdsim Inputs","title":"qdsim Inputs","text":"In this family of methods, the non-Markovian memory is incorporated explicitly by specifying the number of time-steps it spans. For all the TTM-based methods, this memory length is set through the parameter, rmax. For method = \"TEMPO\", it is set through the parameter, kmax.","category":"page"},{"location":"documentation/ParseInput/","page":"qdsim Inputs","title":"qdsim Inputs","text":"Every method has a separate set of parameters that handle the balance between accuracy and efficiency. In case of \"QuAPI-TTM\", that parameter is called cutoff and it is by default set to 10^-10. All paths with absolute value of amplitude below this cutoff are ignored.","category":"page"},{"location":"documentation/ParseInput/","page":"qdsim Inputs","title":"qdsim Inputs","text":"In the case of \"Blip-TTM\", the accuracy is set via the maximum number of blips allowed, max_blips. If this is set to -1, that means all blips are included.","category":"page"},{"location":"documentation/ParseInput/","page":"qdsim Inputs","title":"qdsim Inputs","text":"For \"TEMPO-TTM\", the accuracy is set through the tensor network evaluation parameters. The cutoff of the singular value decomposition, and the maximum bond dimension, maxdim, used in obtaining the matrix product state representation of the path amplitude tensor are the two parameters that are used for controlling the accuracy. The default values of these two parameters are 10^-10 and 1000 respectively.","category":"page"},{"location":"documentation/Simulate/#qdsim-simulate","page":"Simulate Module","title":"qdsim simulate","text":"","category":"section"},{"location":"documentation/Simulate/","page":"Simulate Module","title":"Simulate Module","text":"QuantumDynamicsCLI.Simulate","category":"page"},{"location":"documentation/Simulate/#QuantumDynamicsCLI.Simulate","page":"Simulate Module","title":"QuantumDynamicsCLI.Simulate","text":"Module for simulating the dynamics of the system.\n\n\n\n\n\n","category":"module"},{"location":"documentation/Simulate/","page":"Simulate Module","title":"Simulate Module","text":"QuantumDynamicsCLI.Simulate.run","category":"page"},{"location":"documentation/Simulate/#QuantumDynamicsCLI.Simulate.run","page":"Simulate Module","title":"QuantumDynamicsCLI.Simulate.run","text":"run(system_input, simulate_input)\n\nRun a simulation as specified in the simulation_input TOML file on the system specified in the system_input TOML file.\n\n\n\n\n\n","category":"function"},{"location":"documentation/Simulate/","page":"Simulate Module","title":"Simulate Module","text":"QuantumDynamicsCLI.Simulate.propagate_using_tmats","category":"page"},{"location":"documentation/Simulate/#QuantumDynamicsCLI.Simulate.propagate_using_tmats","page":"Simulate Module","title":"QuantumDynamicsCLI.Simulate.propagate_using_tmats","text":"propagate_using_tmats(system_input, simulate_input)\n\nPropagate a particular density matrix using the transfer tensors generated in a previous path integral simulation.\n\n\n\n\n\n","category":"function"},{"location":"documentation/Simulate/","page":"Simulate Module","title":"Simulate Module","text":"QuantumDynamicsCLI.Simulate.propagate_using_gqme","category":"page"},{"location":"documentation/Simulate/#QuantumDynamicsCLI.Simulate.propagate_using_gqme","page":"Simulate Module","title":"QuantumDynamicsCLI.Simulate.propagate_using_gqme","text":"propagate_using_gqme(system_input, simulate_input)\n\nPropagate a particular density matrix using the generalized quantum master equation. The memory kernel is derived from a previous path integral simulation via the transfer tensor method.\n\n\n\n\n\n","category":"function"},{"location":"documentation/ComonIcon/#Comonicon-Documentation","page":"Comonicon","title":"Comonicon Documentation","text":"","category":"section"},{"location":"documentation/ComonIcon/","page":"Comonicon","title":"Comonicon","text":"QuantumDynamicsCLI.comonicon_install","category":"page"},{"location":"documentation/ComonIcon/#QuantumDynamicsCLI.comonicon_install","page":"Comonicon","title":"QuantumDynamicsCLI.comonicon_install","text":"comonicon_install(;kwargs...)\n\nInstall the CLI manually. This will use the default configuration in Comonicon.toml, if it exists. For more detailed reference, please refer to Comonicon documentation.\n\n\n\n\n\n","category":"function"},{"location":"documentation/ComonIcon/","page":"Comonicon","title":"Comonicon","text":"QuantumDynamicsCLI.comonicon_install_path","category":"page"},{"location":"documentation/ComonIcon/#QuantumDynamicsCLI.comonicon_install_path","page":"Comonicon","title":"QuantumDynamicsCLI.comonicon_install_path","text":"comonicon_install_path(;[yes=false])\n\nInstall the PATH and FPATH to your shell configuration file. You can use comonicon_install_path(;yes=true) to skip interactive prompt. For more detailed reference, please refer to Comonicon documentation.\n\n\n\n\n\n","category":"function"},{"location":"documentation/ComonIcon/","page":"Comonicon","title":"Comonicon","text":"QuantumDynamicsCLI.COMMAND_ENTRY_DOC_STUB","category":"page"},{"location":"documentation/ComonIcon/#QuantumDynamicsCLI.COMMAND_ENTRY_DOC_STUB","page":"Comonicon","title":"QuantumDynamicsCLI.COMMAND_ENTRY_DOC_STUB","text":"Quantum dynamics simulations using QuantumDynamics.jl made a breeze\n\n\n\n\n\n","category":"constant"},{"location":"#QuantumDynamicsCLI","page":"Introduction","title":"QuantumDynamicsCLI","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Documentation\n(Image: Dev)","category":"page"},{"location":"#What-is-QuantumDynamicsCLI?","page":"Introduction","title":"What is QuantumDynamicsCLI?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Simulating the dynamics of quantum systems is a challenging task with a multitude of complicated computational methods. The QuantumDynamics.jl package provides modular open-source implementations of an increasingly growing number of these methods, while remaining a flexible platform for further development. However, owing primarily to its exceptionally flexible nature, the usage of QuantumDynamics.jl happens through short Julia scripts. This means that for the most common simulation jobs, one needs to effectively rewrite the same code multiple times increasing the chances of errors. As a means to making some of the common types of simulations more facile, we now offer the QuantumDynamicsCLI.jl package which installs the qdsim application as a sister code of the QuantumDynamics.jl package. As the framework grows, so will this application grow to accommodate the new methods and their most common use cases.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"QuantumDynamicsCLI.jl is a registered package. Installation is a simple procedure. It can be done either through the Pkg REPL:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"~ julia","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> ]\npkg> add QuantumDynamicsCLI","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"or by using the Pkg package manager in a script as follows:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> using Pkg\njulia> Pkg.add(\"QuantumDynamicsCLI\")","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"After the package gets built, an executable called qdsim will be placed in $HOME/.julia/bin along with the code completions for the shell in $HOME/.julia/completions. Please add $HOME/.julia/bin to your path and source the correct completions file.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"While QuantumDynamicsCLI.jl builds on top of the QuantumDynamics.jl package, separate installation of that package is unnecessary. Just installing QuantumDynamicsCLI.jl would install QuantumDynamics.jl as a dependency.","category":"page"},{"location":"#Basic-Usage","page":"Introduction","title":"Basic Usage","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"qdsim comes as a single program with multiple sub-components. These components can call each other, but are mostly meant for the end-user, and are used for running simulations and post-processing the data. The general syntax for running any particular component is as follows:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"> qdsim <component_name> <command_name> <arguments>","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Currently, two commands are supported:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"simulate: gives access to various techniques for simulating the dynamics\npost: provides post-processing tools for the output","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The most important sub-command of simulate is run, and for post is get-observable.","category":"page"},{"location":"#Types-of-Simulations","page":"Introduction","title":"Types of Simulations","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The primary focus of the qdsim application provided by the QuantumDynamicsCLI.jl package and the underlying QuantumDynamics.jl package is the simulation of dynamics and spectra of open quantum systems. New methods are consistently added and the support for old methods improved. Currently the following methods are supported:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Path Integral Methods using Feynman-Vernon Influence Functional[1]:\nQuasi-adiabatic Propagator Path Integrals (QuAPI) [2, 3]\nBlip QuAPI [4]\nTime-Evolved Matrix Product Operators (TEMPO) [5]\nPairwise-Connected Tensor Network Path Integral (PC-TNPI) [6]\nHierarchical Equations of Motion (HEOM) [7]\nGeneralized Quantum Master Equation (GQME) [8, 9]\nMultichromophore Incoherest Forster Resonance Energy Transfer [10, 11]\nBloch-Redfield Master Equation\nTransfer Tensor Method [12] coupled with any of the path integral methods","category":"page"},{"location":"documentation/Post/#qdsim-post","page":"Post Module","title":"qdsim post","text":"","category":"section"},{"location":"documentation/Post/","page":"Post Module","title":"Post Module","text":"QuantumDynamicsCLI.Post","category":"page"},{"location":"documentation/Post/#QuantumDynamicsCLI.Post","page":"Post Module","title":"QuantumDynamicsCLI.Post","text":"Various routines for post-processing and analysing the simulation results.\n\n\n\n\n\n","category":"module"},{"location":"documentation/Post/","page":"Post Module","title":"Post Module","text":"QuantumDynamicsCLI.Post.merge_into","category":"page"},{"location":"documentation/Post/#QuantumDynamicsCLI.Post.merge_into","page":"Post Module","title":"QuantumDynamicsCLI.Post.merge_into","text":"Combine the source files sources into output. If output does not exist, it is created.\n\nArgs\n\nsources: source output files\noutput: destination output file\n\n\n\n\n\n","category":"function"},{"location":"documentation/References/#References","page":"References","title":"References","text":"","category":"section"},{"location":"documentation/References/","page":"References","title":"References","text":"R. P. Feynman and F. L. Vernon. The Theory of a General Quantum System Interacting with a Linear Dissipative System. Annals of Physics 24, 118–173 (1963).\n\n\n\nN. Makri and D. E. Makarov. Tensor Propagator for Iterative Quantum Time Evolution of Reduced Density Matrices. I. Theory. The Journal of Chemical Physics 102, 4600–4610 (1995).\n\n\n\nN. Makri and D. E. Makarov. Tensor Propagator for Iterative Quantum Time Evolution of Reduced Density Matrices. II. Numerical Methodology. The Journal of Chemical Physics 102, 4611–4618 (1995).\n\n\n\nN. Makri. Blip Decomposition of the Path Integral: Exponential Acceleration of Real-Time Calculations on Quantum Dissipative Systems. The Journal of Chemical Physics 141, 134117 (2014).\n\n\n\nA. Strathearn, P. Kirton, D. Kilda, J. Keeling and B. W. Lovett. Efficient Non-Markovian Quantum Dynamics Using Time-Evolving Matrix Product Operators. Nature Communications 9, 3322 (2018).\n\n\n\nA. Bose. Pairwise Connected Tensor Network Representation of Path Integrals. Physical Review B 105, 024309 (2022).\n\n\n\nY. Tanimura. Numerically ``Exact'' Approach to Open Quantum Dynamics: The Hierarchical Equations of Motion (HEOM). The Journal of Chemical Physics 153, 20901 (2020).\n\n\n\nS. Nakajima. On Quantum Theory of Transport Phenomena. Progress of Theoretical Physics 20, 948–959 (1958).\n\n\n\nR. Zwanzig. On the Identity of Three Generalized Master Equations. Physica 30, 1109–1123 (1964).\n\n\n\nT. Förster. Zwischenmolekulare Energiewanderung Und Fluoreszenz. Annalen der Physik 437, 55–75 (1948).\n\n\n\nS. Jang, M. D. Newton and R. J. Silbey. Multichromophoric Förster Resonance Energy Transfer. Physical Review Letters 92, 218301 (2004).\n\n\n\nJ. Cerrillo and J. Cao. Non-Markovian Dynamical Maps: Numerical Processing of Open Quantum Trajectories. Physical Review Letters 112, 110401 (2014).\n\n\n\n","category":"page"}]
}
